# js作用域

作用域是程序定义变量的可见范围。在JavaScript中包括。

**全局作用域**：代码中任何地方都可以访问的变量。在浏览器中，全局对象是 `window` 对象。也就是说window对象中的所有属性与方法你在哪里都可以访问。

**函数作用域**：在函数内部定义的变量和函数只在函数内部访问，外部无法访问。作用域是分层的，内层作用域可以访问外层作用域，反之不行。

**块级作用域**：在ES6中，使用 `let` 和 `const` 定义的变量在块级作用域内有效，只能在块级作用域内访问。

* 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
* let和const声明的变量不会有变量提升，也不可以重复声明。



## 上下文

每个上下文都有一个关联的**变量对象**（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。比如最外层的变量对象就是`window`。我们通过var定义的变量与函数，都会自动存储在这个对象上面。但是新增的let和const并不会。

上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。

每个函数调用都有自己的上下文。

```
他会与某个对象关联起来。
```

当代码执行流进入函数时，函数的上下文被**推到**一个上下文栈上。在函数执行完之后，上下文栈会**弹出**该函数上下文，将控制权返还给之前的执行上下文。ECMAScript程序的执行流就是通过这个上下文栈进行控制的。

这句话要有图片就很好理解了。先放着把。



## 作用域链

上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。作用域链是JavaScript引擎在**查找变量**时使用的规则。

这个规则就是逐级向上进行获取。举个例子。比如我现在在全局作用域，函数作用域，并在函数内部在创建一个函数，分别创建变量。你需要讲解获取变量的规则是怎么样的。

它由当前执行上下文的变量对象（包括函数参数和内部的变量声明）和所有外部执行上下文的变量对象组成。

上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。



```
#d 是什么
上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。我的理解是查找变量对象中值的顺序。
这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。

#d 执行顺序
这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。


#d 查找方式
作用域链的查找方式是从当前执行上下文开始，逐级向上查找，直到全局上下文。
```



```js
var color = "blue";

function changeColor() {
    let anotherColor = "red";

    function swapColors() {
        let tempColor = anotherColor; //tempcolor = red
        anotherColor = color; // 把重新给antothercolor 赋值为 blue
        color = tempColor;    // 把red 给 color
        // 这里可以访问 color、anotherColor 和 tempColor
        console.log(color, anotherColor, tempColor);
        // red blue red
    }

    // 这里可以访问 color 和 anotherColor，但访问不到 tempColor
    swapColors();
    // 这是在changecolor中运行的
}

// 这里只能访问 color
changeColor(); // 输出red

console.log(color); // color的值被修改了。
```





## 类比

## vue vuex vue router 中的作用域链

在Vue和Vuex中，作用域链的概念并不直接存在。Vue和Vuex主要通过组件的props和Vuex的store来传递数据，而不是通过作用域链。



在Vue和Vuex中，有一些类似于作用域链的机制，但它们并不完全等同于作用域链。

1. **Vue的组件作用域**：在Vue中，每个组件都有自己的作用域。组件的数据、方法、生命周期钩子等都在这个作用域内。组件之间的数据交互通常通过props和自定义事件来实现。
2. **Vuex的store**：Vuex的store是一个全局的状态管理容器，所有的状态都存储在store中。组件可以通过Vuex的getters和mutations来访问和修改store中的状态。
3. **Vue的插槽（slot）**：Vue的插槽机制可以看作是一种作用域的扩展。父组件可以通过插槽向子组件传递内容，子组件可以通过插槽访问父组件的数据。
4. **Vue的计算属性和监听器**：Vue的计算属性和监听器可以看作是一种作用域的扩展。计算属性和监听器可以依赖于其他数据，当这些数据发生变化时，计算属性和监听器会自动更新。



## 作用域意识

可以把这个写进去。

## Vuex 类似于模块作用域

Vuex在Vue.js中扮演的角色类似于JavaScript中的模块作用域。

在JavaScript中，模块作用域是一种设计模式，它通过函数作用域和闭包来创建私有变量和方法。在模块作用域中，变量和函数只能在模块内部访问，不能在模块外部访问。这样可以防止全局变量的污染，提高代码的可维护性和可读性。

在Vuex中，store也是一个模块，它包含了应用的所有状态。Vuex的store可以被视为一个全局的数据存储，所有的组件都可以访问和修改store中的数据。Vuex的store提供了一些方法（如getters和mutations）来访问和修改store中的数据，这些方法只能在store内部访问，不能在store外部访问。

因此，Vuex的store在Vue.js中扮演的角色类似于JavaScript中的模块作用域，它提供了私有状态和方法，防止了全局状态的污染，提高了代码的可维护性和可读性。



# 对作用域、作用域链的理解

##### 1）全局作用域和函数作用域

（1）全局作用域

* 最外层函数和最外层函数外面定义的变量拥有全局作用域
* 所有未定义直接赋值的变量自动声明为全局作用域
* 所有window对象的属性拥有全局作用域
* 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

（2）函数作用域

* 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
* 作用域是分层的，内层作用域可以访问外层作用域，反之不行

##### 2）块级作用域

* 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
* let和const声明的变量不会有变量提升，也不可以重复声明
* 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

**作用域链：** 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用是**保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。**

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。



### 3. 对执行上下文的理解

##### 1. 执行上下文类型

**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

**（3）**`eval`**函数执行上下文**

执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。

##### 2. 执行上下文栈

* JavaScript引擎使用执行上下文栈来管理执行上下文.

    当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

```js
let a = 'Hello World!';
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}
function second() {
  console.log('Inside second function');
}
first();
//执行顺序
//先执行second(),在执行first()

```

**1）创建阶段**

（1）this绑定

* 在全局执行上下文中，this指向全局对象（window对象）
* 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined

（2）创建词法环境组件

* 词法环境是一种有**标识符——变量映射**的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。
* 词法环境的内部有两个组件：**加粗样式**：环境记录器:用来储存变量个函数声明的实际位置**外部环境的引用**：可以访问父级作用域

（3）创建变量环境组件

* 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。

**2）执行阶段** 此阶段会完成对变量的分配，最后执行完代码。

**简单来说执行上下文就是指：**

在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。

* 全局上下文：变量定义，函数声明
* 函数上下文：变量定义，函数声明，`this`，`arguments`



# 变量声明

变量声明就是定义变量可访问的范围区间。目前JavaScript中存在三种定义变量的关键字。var let 和const。

## var

在使用 var 声明变量时，变量会被自动添加到最接近的上下文。控制台默认的上下文为window对象，所以在控制台定义的变量会自动添加到window对象中。在下面的例子中，通过var 定义的 result为add函数内部的**局部变量**。它的值外部无法访问。值会随着函数的执行而销毁，且声明不会影响到全局作用域。比如下面例子，我们声明了一个相同变量名的变量。控制台并没有报错。记住他们只是名字一样。

```js
function add(sum, sum1) {
	var sums = sum + sum1
	return sums
}

let result = add(10,12) // 22
console.log(result); // 报错：sum 在这里不是有效变量

var sums = 20
console.log(sums); // 20
```

如果不用var关键字定义，通过变量名赋值的方式就是一个全局变量。需要注意的是，函数必须执行才可以。

```js
function test1 () {
	test = "全局变量"
}
test1()
console.log(test); // "全局变量"
```

### 随意更改值

这里，message 被定义为一个保存字符串值 hi 的变量。像这样初始化变量不会将它标识为**字符串类型**，只是一个简单的赋值而已。随后，不仅可以改变保存的值，也可以改变值的类型：

```
var message = "hi"; 

**message = 100; //** **合法，但不推荐**
```

### 变量提升（自动提到了函数作用域的顶部）

```
也就是把所有变量声明都拉到当前作用域的顶部.

log(test)
var test
test = 111

这样不会报错，自动提升到函数作用域的顶部。
```





let 声明的范围是块作用域，而 var 声明的范围是函数作用域。块作用域是函数作用域的子集。变量访问与修改只能在某一个块级范围之内，他们之间定义相同名字的1变量也不会存在保存。块级与块级之间的作用域变量不冲突。let不存在变量提升。也就是说不能先访问后定义变量。这个机制叫做暂时性死区。





const 的行为与 let 基本相同，重要区别在于，声明变量时必须赋值，且尝试修改 const 声明的变量会导致运行时错误。
