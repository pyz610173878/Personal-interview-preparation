# js作用域

## 上下文

上下文指得是执行js代码时，创建的一个上下文环境，这个环境关联着一个**变量对象**（variable object），他保存着执行环境中的所定义的全部变量与函数，（也就是说当前执行环境定义的变量会自动存储在这个变量对象中）所以上下文决定了它们能够访问哪些数据与行为。在一个函数执行之前，也会创建一个函数执行上下文环境，并创造一个作用域链，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。上下文也分层级关系，最外层的上下文为全局上下文，当我们在浏览器控制台中，使用var定义的全局变量和函数都会成为 window 对象的属性和方法。因为我们是在全局上下文中定义的变量。

## 作用域

作用域是程序定义变量的可见范围。在JavaScript中包括。

**全局作用域**：代码中任何地方都可以访问的变量。在浏览器中，全局对象是 `window` 对象。也就是说window对象中的所有属性与方法你在哪里都可以访问。

**函数作用域**：在函数内部定义的变量和函数只在函数内部访问，外部无法访问。作用域是分层的，内层作用域可以访问外层作用域，反之不行。

**块级作用域**：在ES6中，使用 `let` 和 `const` 定义的变量在块级作用域内有效，只能在块级作用域内访问。

* 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
* let和const声明的变量不会有变量提升，也不可以重复声明。

## 作用域链

作用域链是JavaScript引擎在**查找变量**时使用的规则。上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链由当前执行上下文的变量对象（包括函数参数和内部的变量声明）和所有外部执行上下文的变量对象组成。而它决定了各级上下文中的代码在访问变量和函数时的顺序。作用域链的查找方式是从**当前**执行上下文开始，逐级向上查找，直到全局上下文。

```js
var color = "blue";

function changeColor() {
    let anotherColor = "red";

    function swapColors() {
        let tempColor = anotherColor; //tempcolor = red
        anotherColor = color; // 把重新给antothercolor 赋值为 blue
        color = tempColor;    // 把red 给 color
        // 这里可以访问 color、anotherColor 和 tempColor
        console.log(color, anotherColor, tempColor);
        // red blue red
    }

    // 这里可以访问 color 和 anotherColor，但访问不到 tempColor
    swapColors();
    // 这是在changecolor中运行的
}

// 这里只能访问 color
changeColor(); // 输出red

console.log(color); // color的值被修改了。
```



# 闭包 

## 是什么

闭包是指内部函数引用外部函数的变量的集合。我也搜了大量的资料，掘金，mdn，js高级设计，你不知道的js。他们对闭包的定义都是不相同，但我觉得他们的描述都非常抽象。一个非常直观理解闭包的方式，就是打开vscode调试器，在左边会显示一个值，closure。而这里面就是各种值，所以我们也可以看成是一个集合。

## 应用场景

闭包是为了`创建函数的私有变量`，且这个变量不会随着函数执行完毕被垃圾回收机制回收。比如jquery的实现，就使用了闭包。来创建了私有变量。它所暴露给全局的只有一个美元符号。

## 类比

我们可以把闭包理解为闭塞的，封闭的，或者说把东西包起来（藏起来）。

比如，小时候会把压岁钱藏起来不要其他人发现。我把这个钱藏了某个书壳里，我们只把书壳暴露在了外面，其他人无法看到钱，在js中就是无法读取这个变量。

## 副作用 内存泄漏

因为匿名函数的作用域链中仍然有对它的引用。父函数执行完毕后，其执行上下文的作用域链会销毁，但它的各种变量仍然会保留在内存中，直到匿名函数被销毁后才会被销毁。



## 如何解决

解决办法。我们可以手动解除闭包，即将对内部函数的引用删除。例如，可以将内部函数赋值为 null，或者将外部函数返回的引用赋值为 null。



## 类比

## vue vuex vue router 中的作用域链

在Vue和Vuex中，作用域链的概念并不直接存在。Vue和Vuex主要通过组件的props和Vuex的store来传递数据，而不是通过作用域链。

在Vue和Vuex中，有一些类似于作用域链的机制，但它们并不完全等同于作用域链。

1. **Vue的组件作用域**：在Vue中，每个组件都有自己的作用域。组件的数据、方法、生命周期钩子等都在这个作用域内。组件之间的数据交互通常通过props和自定义事件来实现。
2. **Vuex的store**：Vuex的store是一个全局的状态管理容器，所有的状态都存储在store中。组件可以通过Vuex的getters和mutations来访问和修改store中的状态。
3. **Vue的插槽（slot）**：Vue的插槽机制可以看作是一种作用域的扩展。父组件可以通过插槽向子组件传递内容，子组件可以通过插槽访问父组件的数据。
4. **Vue的计算属性和监听器**：Vue的计算属性和监听器可以看作是一种作用域的扩展。计算属性和监听器可以依赖于其他数据，当这些数据发生变化时，计算属性和监听器会自动更新。



## Vuex 类似于模块作用域

Vuex在Vue.js中扮演的角色类似于JavaScript中的模块作用域。

在JavaScript中，模块作用域是一种设计模式，它通过函数作用域和闭包来创建私有变量和方法。在模块作用域中，变量和函数只能在模块内部访问，不能在模块外部访问。这样可以防止全局变量的污染，提高代码的可维护性和可读性。

在Vuex中，store也是一个模块，它包含了应用的所有状态。Vuex的store可以被视为一个全局的数据存储，所有的组件都可以访问和修改store中的数据。Vuex的store提供了一些方法（如getters和mutations）来访问和修改store中的数据，这些方法只能在store内部访问，不能在store外部访问。

因此，Vuex的store在Vue.js中扮演的角色类似于JavaScript中的模块作用域，它提供了私有状态和方法，防止了全局状态的污染，提高了代码的可维护性和可读性。

# 变量声明

变量声明就是定义变量可访问的范围区间。目前JavaScript中存在三种定义变量的关键字。var let 和const。

## var

在使用 var 声明变量时，变量会被自动添加到最接近的上下文。控制台默认的上下文为window对象，所以在控制台定义的变量会自动添加到window对象中。在下面的例子中，通过var 定义的 result为add函数内部的**局部变量**。它的值外部无法访问。值会随着函数的执行而销毁，且声明不会影响到全局作用域。比如下面例子，我们声明了一个相同变量名的变量。控制台并没有报错。记住他们只是名字一样。

```js
function add(sum, sum1) {
	var sums = sum + sum1
	return sums
}

let result = add(10,12) // 22
console.log(result); // 报错：sum 在这里不是有效变量

var sums = 20
console.log(sums); // 20
```

如果不用var关键字定义，通过变量名赋值的方式就是一个全局变量。需要注意的是，函数必须执行才可以。

```js
function test1 () {
	test = "全局变量"
}
test1()
console.log(test); // "全局变量"
```

### 随意更改值

这里，message 被定义为一个保存字符串值 hi 的变量。像这样初始化变量不会将它标识为**字符串类型**，只是一个简单的赋值而已。随后，不仅可以改变保存的值，也可以改变值的类型：

```
var message = "hi"; 

**message = 100; //** **合法，但不推荐**
```

### 变量提升（自动提到了函数作用域的顶部）

```
也就是把所有变量声明都拉到当前作用域的顶部.

log(test)
var test
test = 111

这样不会报错，自动提升到函数作用域的顶部。
```



let 声明的范围是块作用域，而 var 声明的范围是函数作用域。块作用域是函数作用域的子集。变量访问与修改只能在某一个块级范围之内，他们之间定义相同名字的1变量也不会存在保存。块级与块级之间的作用域变量不冲突。let不存在变量提升。也就是说不能先访问后定义变量。这个机制叫做暂时性死区。

const 的行为与 let 基本相同，重要区别在于，声明变量时必须赋值，且尝试修改 const 声明的变量会导致运行时错误。

# 总结

不要改了，就这样了。把他背下来。管他的就是背下来。

这些面试题无论我看多少遍，只要好几天没看就记不住了。所以我现在看是没有必要的。我只要在面试的前几天看一下，然后当天描述出来不就可以了吗？对不对？现在反正会忘记。还不如直接背他们的。









