# 类与对象

原型链是js实现继承的一种机制。继承源于面向对象编程范式，他不是某个编程语言所特有的，他是软件编程里的思维方法和设计方法。面向对象的方法把一切事物都看作“**对象**（*object*）”，而把类似事物的共性特征抽象出来称为“**类**（*class*）”。反过来说，*class* 定义一类事物的特征，就像一个模板，需要时可以按照这个模板创造（或者描述）一个具体的 *object* 出来。

举例来说，我的工作台上有个台灯，这个台灯是一个对象，它拥有亮度、色温、电压等属性，还有一个操作界面——开关，操作一次就打开了，再操作一次就关了。

经过仔细思考，我们发现所有的灯基本都有这些属性和操作界面，所以我们可以抽象出一个“灯”的类（*class*）来，有亮度、色温、电压这些属性。

对象有两个重要的概念。

这种被选出来的“必要的特征”，叫做对象的“**属性**（*attributes*）”，进而，这些抽象的对象，实际上也能做一些抽象过后被保留下来的“必要的行为”，比如，说话，哭笑，这些叫做对象的“**方法**（*methods*）”。

从面向对象的编程语言角度去看世界，要定义一类事物，就建立一个 *class*，*class* 定义两类东西：

* **属性**：用自然语言描述，通常是名词，表示这类事物拥有的共性特征；
* **方法**：用自然语言描述，通常是动词，表示我们可以对这类事物做什么，或者请求它做什么。

# 访问控制

面向对象的语言允许设置类的属性和方法是否对外可见，外部可以访问的叫公共的（*public*），不可见的叫私有的（*private*）。

简言之，类的 *public* 部分就像店铺的门面招牌，里面可以随便折腾，但招牌轻易不能动。我们把公共的属性与方法。也叫做`接口`英文名，interface。

## es6 新增了interface定义属性

在ts中，就新增了interface关键字。

# 抽象层次

为什么需要有继承呢？举个例子，es6新增的symbol数据类型，他拥有基础数据类型的很多特征。一些属性都是存在的。只需要添加一些其他的方法就可以了。难道我们要全部重写一些所以属性与方法吗？这样既重复又不好维护。

而面向对象的方法提供了现成的解决方案：**继承**和**子类**。我们可以为某个类创建一个子类，这个子类拥有父类的一切（不需要再写一遍）属性与方法，然后还可以拥有自己添加的任何东西，这叫做“**继承**（*inheritance*）”。举个例子，在js中，除object其他数据类型都继承自object原型，我们就可以说其他数据都是object的子类，这些数据类型拥有object的所有属性与方法，然后他们自己添加了属于自己的方法。（有些不会继承，或者是无法访问）。



# 原型链概念





## 是什么

原型链是JavaScript中实现继承的一种主要机制。虽然es6新增了class类继承，但背后依旧使用的是原型链继承。

## 类似于什么

它与面向对象继承非常相似。

## 实例对象与原型对象

面向对象的方法把一切事物都看作“**实例对象**（*object*）”，而把类似事物的共性特征抽象出来称为“**原型对象**”。反过来说，*原型对象* 定义一类事物的特征，就像一个模板，需要时可以按照这个模板创造（或者描述）一个具体的 *object* 出来。

这里需要举一个例子。

构造函数是JavaScript中创建原型对象的语法方式。每个实例对象（object）都有一个私有属性（称之为 __proto__ ）我们把这个所指向的值，称作对象的原型。而该原型对象自身的（__proto__）也会指向另外一个原型对象，原型与原型通过proto进行连接，就像链条一样绑定在一起，这样就形成了一个原型链。

## d子概念 私有属性

原型链中的属性与方法是共享的。

 比如，创造一个String类型的实例对象，他是一个字符串。然后调用某个方法，此时解析器会从String构造函数出发，再到他的对象原型，也就是object寻找。在举一个例子。在vue2中，Vue是一个构造函数，我们使用vue的方式，就是实例化一个vue对象。vue的顶层对象也是object的。



### 属性与方法 的共享

构造函数会定义两类东西。属性与方法。

**属性**：用自然语言描述，通常是名词，表示这类事物拥有的共性特征；

**方法**：用自然语言描述，通常是动词，表示我们可以对这类事物做什么，或者请求它做什么.

例如我们发现所有动物都存在它的种类与名字和喊叫方式。我们就可以把特征抽象出来写在构造函数中。把种类与名字写成属性，而把喊叫方式写成函数。在原型链中，属性与方法是共享的，这样实现了复用。如果在当前对象中查找某个属性或方法时，当前对象不存在该属性或方法，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法为止，或者查找到原型链的顶端。



##  instanceof的原理

## 不是什么 是什么

首先instanceof他不是一个函数，而是一个操作符。类似作用的运算符，在java c# 和python中都有。因为他们都支持面向对象编程范式。

### 作用

instanceof运算符的原理是通过检查object的原型链是否包含constructor的原型对象。如果存在则返回true，反之返回false。`constructor`是一个特殊的属性，它指向创建该对象的构造函数。比如我们有一个animal的构造函数，生成了一个cat实例对象。那么cat的constructor就指向构造函数`animal`。

## 拓展

需要注意的是，instanceof运算符只能用于检查对象是否是某个构造函数的实例，不能用于基本类型（如字符串、数字等）的检查。如果检查的对象不是一个对象类型，instanceof会输出false

## 缺点

由于instanceof是基于原型链的检查，就像链表的遍历，他无法进行跳过，如果某个对象的链条过长，那么检查的效率就会比较慢。所以我们一般会使用forEach遍历对象的属性，并基于这些属性执行操作。

## 手写

```java
function myInstanceOf(obj, constructor) {   
	let proto = Object.getPrototypeOf(obj); // 获取 obj 的原型   
	while (proto) {     
		if (proto === constructor.prototype) {       
		return true;     
		}    
        proto = Object.getPrototypeOf(proto); // 获取原型链上的下一个原型   
        }   
        return false; }
```

## 性能问题

他类似于，链表中节点值的遍历，此外，当尝试访问不存在的属性始终会遍历整个原型链。

## 修改原型（重写 属性与方法）

如何实现覆盖呢？虽然他们存在共同特征，但也有一些不同的特征与方法。或者他们虽然存在同样的方法，但是产生的结果是需要不一样的。也就是我们需要修改，或者讲做覆盖原方法。

# 如何实例化 New 的原理

`new`关键字用于创建对象或构造函数的实例对象。`new`操作符遵循一个特定的步骤集。

1. 创建一个空的简单 JavaScript 对象（即 **`{}`**）；
2. 为步骤 1 新创建的对象添加属性 **`__proto__`**，将该属性链接至构造函数的原型对象；
3. 将步骤 1 新创建的对象作为 **`this`** 的上下文；
4. 如果该函数没有返回对象，则返回 **`this`**。

## 示例

假设你要创建一个汽车的对象类型。你希望这个类型叫做 car，这个类型具备 make, model, year 等属性，要做到这些，你需要写这样一个函数：

```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
var mycar = new Car("Eagle", "Talon TSi", 1993);

```

## 手写

```javascript
function NewObj (yx, ...args) {
    var Obj = Object.create(yx.prototype)

    var result = yx.apply(Obj, args)

    return result instanceof Object ? result : Obj;
}

function Person(name, age) {
    this.name = name
    this.age = age
}

var new1 = NewObj(Person, "pyz", 18)

console.log(new1.name); // "pyz"
console.log(new1.age); // 18

不能使用箭头函数，箭头函数没有this指向。因为构造函数存在多参数，所以需要使用args语法。


```



## 手写 Objet.create

```javascript
function createObject(proto) {
    function F() {}
    F.prototype = proto;
    return new F();
}
```



##  new与creat之间的区别

相同之处：都是生成某一个构造函数的实例对象。

不同之处：create不会执行构造函数。它只会创建一个新对象，并将其原型设置为指定的对象。







用来判断，实例对象是否存在于某个原型的原型链中







this是一个关键字，在英文世界中他的语义是指向某个事物，而在Js中也是相同的意思，只不过在js，绝大部分情况是指向调用ta'de