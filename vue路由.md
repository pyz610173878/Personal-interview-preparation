Vue是一个渐进式JavaScript框架，它专注于构建用户界面。Vue的核心思想是**数据驱动**和组件化。数据驱动意味着 Vue.js 会自动跟踪数据的变化，并更新相应的视图。组件化意味着你可以将应用程序的 UI 划分为独立的、可复用的组件。每个组件都有自己的模板、逻辑和样式。可以更好地管理代码，提高代码的复用性和可维护性。

Vue的响应式数据绑定机制是Vue最核心的特性之一。通过对数据进行劫持和监听，可以实现数据的双向绑定，即数据变化会自动更新视图，同时视图的变化也会反映到数据上。这种机制使得Vue的数据流非常清晰和可预测，同时也减少了开发的工作量。

另外一个重要特性是其模板语法，它允许开发者使用 HTML 和 JavaScript 的组合来描述用户界面。Vue.js 的模板语法是声明式的，这意味着开发者只需要描述他们想要的结果，而不需要手动操作 DOM。

Vue的优势在于其简单易用、灵活性高、性能卓越和扩展性强。Vue的模板语法易于理解和学习，可以快速构建交互式的Web应用程序。

同时，Vue的生命周期钩子和自定义指令等功能，使得Vue可以满足各种复杂的需求。

另外，Vue还提供了Vuex、Vue Router等官方插件，可以进一步扩展Vue的功能。 



在 Vue Router 中，导航钩子主要用于在路由跳转过程中执行一些操作。Vue Router 提供了全局的、单个路由独享的和组件级的导航钩子。

以下是 Vue Router 的导航钩子：

1. 全局的导航钩子：
    * `router.beforeEach`：在路由跳转之前调用。
    * `router.beforeResolve`：在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后调用。
    * `router.afterEach`：在路由跳转之后调用。
2. 单个路由独享的导航钩子：
    * `beforeEnter`：在路由跳转之前调用。
3. 组件级的导航钩子：
    * `beforeRouteEnter`：在路由进入之前调用。
    * `beforeRouteUpdate`：在当前路由改变，但是该组件被复用时调用。
    * `beforeRouteLeave`：在导航离开渲染该组件的对应路由时调用。

这些钩子函数都可以接收三个参数：`to`（即将进入的路由），`from`（即将离开的路由），`next`（必须调用以解析钩子）。

注意：在 `beforeRouteEnter` 钩子中，不能访问 `this`，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。不过，你可以通过传一个回调给 `next` 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。









## afterEach

after在什么之后，在路由跳转之后。

因为它可以在每次路由跳转之后执行一些操作。记录日志，或者在导航之后执行一些清理工作。





# Vue-router 核心原理

总之，Vue Router是实现Vue.js单页应用路由控制的核心组件之一，它通过路由匹配、路由模式、路由导航、路由组件等多个方面实现了完整的路由控制逻辑，为开发者提供了强大的路由控制能力





Vue Router的History模式相比于默认的Hash模式来说，能够更好地模拟传统的多页面应用的URL地址，让用户体验更加自然。但是，使用History模式需要注意以下几点事项： 

后端配置：使用History模式需要后端对所有可能的路由路径都进行处理，以避免在刷新或直接输入URL时出现404错误。后端配置的方式取决于后端服务器的类型，如Apache、Nginx等，需要在服务器上进行相关配置。

 安全性：使用History模式会暴露出服务器上的文件路径，因此需要特别注意安全性。在部署时需要仔细检查服务器配置，确保不会因为恶意请求而导致安全问题。 

兼容性：History模式需要支持HTML5的history.pushState API，因此在一些较老的浏览器上可能会存在兼容性问题。需要在开发时做好相关的测试和兼容性处理。 

打包发布：在使用Webpack等工具打包发布时，需要配置正确的publicPath，保证HTML中引用的资源路径正确。同时需要注意，如果项目使用了多个子路由，需要在打包时将所有的子路由都配置到publicPath中。 总之，使用History模式需要对后端进行相关配置，并且需要特别注意安全性和兼容性问题，同时在打包发布时需要正确配置publicPath，确保页面资源路径正确。





# Vue Router history 模式为什么刷新出现404

原因是因为浏览器在刷新页面时会向服务器发送GET请求，但此时服务器并没有相应的资源来匹配这个请求，因为在History模式下，所有路由都是在前端路由中实现的，并没有对应的后端资源文件。



## 解决方案

为了解决这个问题，我们需要在服务器端进行相关配置，让所有的路由都指向同一个入口文件（比如index.html），由前端路由来处理URL请求，返回对应的页面内容。具体的配置方式取决于服务器类型，常见的有Apache、Nginx等。

这段代码会将所有请求都指向根目录下的index.html文件，让前端路由来处理URL请求。同时需要注意，在使用History模式时需要保证所有路由的访问路径都指向index.html，否则仍然会出现404错误。