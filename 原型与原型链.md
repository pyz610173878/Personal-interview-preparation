# 原型链概念

## 是什么

解释一下原型链 讲概念 原型链是JavaScript中实现继承的一种机制。

## 类似于什么

它类似于类的继承，但又不完全是。他们之间的共性。提高复用性，符合模块化编程规范。

## d子概念 私有属性

引用类型可以添加属性与方法。

每个实例对象（object）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype）。
该原型对象也有一个自己的原型对象（__proto__），层层向上直到一个对象的原型对象为 null 。这样就形成了一个原型链。

 比如，创造一个String类型的实例对象，他是一个字符串。然后调用某个方法，此时解析器会从String构造函数出发，再到他的对象原型，也就是object寻找。在举一个例子。在vue2中，Vue是一个构造函数，我们使用vue的方式，就是实例化一个vue对象。vue的顶层对象也是object的。



### 属性与方法 的共享

构造函数里面存在属性与方法。属性对应着**名词**。方法对应着**动词**。例如，如果我们正在为一所学校建模，我们可能有学生，（有低年级，高年级）老师也存在不同科目的老师：我们可以剔除细节，抽取他们之间的共同特征。比如（名字，年龄，性别），但每个人都可能增加额外的特征（例如，教授有一个他们所教的科目），在oop编程范式中，我们把这些特征叫做属性。对应在程序语言中，就是各种数据类型。而方法对应着行为。比如学生需要思考，小猫有猫猫叫。小狗有犬叫。xx就是函数，处理值的过程。

除构造函数的静态方法。原型链中的属性与方法是共享的，实现了复用。如果在当前对象中查找某个属性或方法时，当前对象不存在该属性或方法，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法为止，或者查找到原型链的顶端。

## 查找方法原理

##  instanceof的原理

## 不是什么 是什么

首先instanceof他不是一个函数，而是一个操作符。

作用

他用于检测构造函数的prototype属性，是否出现在某个实例对象的原型链中。如果实例对象的原型链上存在构造函数的 `prototype` 属性则返回true，否则返回false。

举例子

比如我现在有两个构造函数，分别是Dog和Cat。分别创造了实例对象，边牧和狸花猫。我在野外看见了一朵非常漂亮的话，但我不知道这个花具体属于哪个中的，我知道他属于哪个科。我们可以用某种工具来判断他是否属于你确认的那个种类。instanceof也是这个作用。

与之类似作用的运算符

类似作用的运算符，在java c# 和python中都有。

## 拓展

需要注意的是，instanceof运算符只能用于检查对象是否是某个构造函数的实例，不能用于基本类型（如字符串、数字等）的检查。如果检查的对象不是一个对象类型，instanceof会输出false

## 缺点

由于instanceof是基于原型链的检查，就像链表的遍历，他无法进行跳过，如果某个对象的链条过长，那么检查的效率就会比较慢。所以我们一般会使用forEach遍历对象的属性，并基于这些属性执行操作。

## 手写

```java
function myInstanceOf(obj, constructor) {   
	let proto = Object.getPrototypeOf(obj); // 获取 obj 的原型   
	while (proto) {     
		if (proto === constructor.prototype) {       
		return true;     
		}    
        proto = Object.getPrototypeOf(proto); // 获取原型链上的下一个原型   
        }   
        return false; }
```

首先获取Obj的原型。获取方法是使用`xx方法`

例如，假设有一个对象 obj，它的原型对象为 proto，而 proto 的原型对象为 proto2，那么在查找 obj 的属性或方法时，JavaScript 引擎会按照以下顺序进行查找： 
1 在 obj 本身中查找该属性或方法。 
2 如果 obj 中不存在该属性或方法，则在 proto 中查找。 
3 如果 proto 中也不存在该属性或方法，则继续在 proto2 中查找，以此类推，直到查找到 Object.prototype。 
4 如果在 Object.prototype 中仍然没有找到该属性或方法，则返回 undefined。 这个查找过程就构成了原型链。在 JavaScript 中，对象的原型对象可以通过 __proto__ 属性或 Object.getPrototypeOf() 方法获取。 

原型链的作用在于实现了 JavaScript 中的继承。当一个对象需要继承另一个对象的属性和方法时，可以将父对象设置为子对象的原型对象，从而使子对象能够沿着原型链访问父对象的属性和方法。



## 性能问题

他类似于，链表中节点值的遍历，此外，当尝试访问不存在的属性始终会遍历整个原型链。

## 修改原型（重写 属性与方法）

如何实现覆盖呢？虽然他们存在共同特征，但也有一些不同的特征与方法。或者他们虽然存在同样的方法，但是产生的结果是需要不一样的。也就是我们需要修改，或者讲做覆盖原方法。

## 多态

我觉得需要讲。

# 如何实例化 New 的原理

`new`关键字用于创建对象或构造函数的实例对象。`new`操作符遵循一个特定的步骤集。

1. 创建一个空的简单 JavaScript 对象（即 **`{}`**）；
2. 为步骤 1 新创建的对象添加属性 **`__proto__`**，将该属性链接至构造函数的原型对象；
3. 将步骤 1 新创建的对象作为 **`this`** 的上下文；
4. 如果该函数没有返回对象，则返回 **`this`**。

## 示例

假设你要创建一个汽车的对象类型。你希望这个类型叫做 car，这个类型具备 make, model, year 等属性，要做到这些，你需要写这样一个函数：

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
var mycar = new Car("Eagle", "Talon TSi", 1993);

```

## 手写

```
function NewObj (yx, ...args) {
    var Obj = Object.create(yx.prototype)

    var result = yx.apply(Obj, args)

    return result instanceof Object ? result : Obj;
}

function Person(name, age) {
    this.name = name
    this.age = age
}

var new1 = NewObj(Person, "pyz", 18)

console.log(new1.name); // "pyz"
console.log(new1.age); // 18

不能使用箭头函数，箭头函数没有this指向。因为构造函数存在多参数，所以需要使用args语法。
```



## 手写 Objet.create

```javascript
function createObject(proto) {
    function F() {}
    F.prototype = proto;
    return new F();
}
```



##  new与creat之间的区别

相同之处：都是生成某一个构造函数的实例对象。

不同之处：create不会执行构造函数。它只会创建一个新对象，并将其原型设置为指定的对象