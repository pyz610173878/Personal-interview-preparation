# 原型链概念

如果面试官问到，js的数据类型有哪些。你不要仅仅只复述那几个名词。你要详细说他们之间的共性与区别。

2. 如何判断数据类型，有哪些方法。
3. 扩展，其实这些数据类型就是



## 是什么

原型链是JavaScript中实现继承的一种主要机制。虽然es6新增了class类继承，但背后依旧使用的是原型链继承。

## 类似于什么

它与面向对象继承非常相似。

## 实例对象与原型对象

面向对象的方法把一切事物都看作“**实例对象**（*object*）”，而把类似事物的共性特征抽象出来称为“**原型对象**”。反过来说，*原型对象* 定义一类事物的特征，就像一个模板，需要时可以按照这个模板创造（或者描述）一个具体的 *object* 出来。

这里需要举一个例子。

## d子概念 私有属性

每个实例对象（object）都有一个私有属性（称之为 __proto__ ）它的值指向它的构造函数的原型对象（prototype）。构造函数是JavaScript中实现原型对象的语法方式。而该原型对象自身的（__proto__）也会指向另外一个原型对象，原型与原型通过proto进行连接，就像链条一样绑定在一起，我们把这种情况叫做原型链。

```
Array.prototype里面有各种属性与方法，然后还有一个prototype属性，指向它的上一层原型对象。
```

 比如，创造一个String类型的实例对象，他是一个字符串。然后调用某个方法，此时解析器会从String构造函数出发，再到他的对象原型，也就是object寻找。在举一个例子。在vue2中，Vue是一个构造函数，我们使用vue的方式，就是实例化一个vue对象。vue的顶层对象也是object的。



### 属性与方法 的共享

构造函数会定义两类东西。属性与方法。

**属性**：用自然语言描述，通常是名词，表示这类事物拥有的共性特征；

**方法**：用自然语言描述，通常是动词，表示我们可以对这类事物做什么，或者请求它做什么.

例如我们发现所有动物都存在它的种类与名字和喊叫方式。我们就可以把特征抽象出来写在构造函数中。把种类与名字写成属性，而把喊叫方式写成函数。在原型链中，属性与方法是共享的，这样实现了复用。如果在当前对象中查找某个属性或方法时，当前对象不存在该属性或方法，JavaScript 引擎会沿着原型链向上查找，直到找到该属性或方法为止，或者查找到原型链的顶端。

##  instanceof的原理

## 不是什么 是什么

首先instanceof他不是一个函数，而是一个操作符。类似作用的运算符，在java c# 和python中都有。因为他们都支持面向对象编程范式。

### 作用

他用于检测构造函数的prototype属性，是否出现在某个实例对象的原型链中。如果实例对象的原型链上存在构造函数的 `prototype` 属性则返回true，否则返回false。

## 拓展

需要注意的是，instanceof运算符只能用于检查对象是否是某个构造函数的实例，不能用于基本类型（如字符串、数字等）的检查。如果检查的对象不是一个对象类型，instanceof会输出false

## 缺点

由于instanceof是基于原型链的检查，就像链表的遍历，他无法进行跳过，如果某个对象的链条过长，那么检查的效率就会比较慢。所以我们一般会使用forEach遍历对象的属性，并基于这些属性执行操作。

## 手写

```java
function myInstanceOf(obj, constructor) {   
	let proto = Object.getPrototypeOf(obj); // 获取 obj 的原型   
	while (proto) {     
		if (proto === constructor.prototype) {       
		return true;     
		}    
        proto = Object.getPrototypeOf(proto); // 获取原型链上的下一个原型   
        }   
        return false; }
```

## 性能问题

他类似于，链表中节点值的遍历，此外，当尝试访问不存在的属性始终会遍历整个原型链。

## 修改原型（重写 属性与方法）

如何实现覆盖呢？虽然他们存在共同特征，但也有一些不同的特征与方法。或者他们虽然存在同样的方法，但是产生的结果是需要不一样的。也就是我们需要修改，或者讲做覆盖原方法。

# 如何实例化 New 的原理

`new`关键字用于创建对象或构造函数的实例对象。`new`操作符遵循一个特定的步骤集。

1. 创建一个空的简单 JavaScript 对象（即 **`{}`**）；
2. 为步骤 1 新创建的对象添加属性 **`__proto__`**，将该属性链接至构造函数的原型对象；
3. 将步骤 1 新创建的对象作为 **`this`** 的上下文；
4. 如果该函数没有返回对象，则返回 **`this`**。

## 示例

假设你要创建一个汽车的对象类型。你希望这个类型叫做 car，这个类型具备 make, model, year 等属性，要做到这些，你需要写这样一个函数：

```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
var mycar = new Car("Eagle", "Talon TSi", 1993);

```

## 手写

```
function NewObj (yx, ...args) {
    var Obj = Object.create(yx.prototype)

    var result = yx.apply(Obj, args)

    return result instanceof Object ? result : Obj;
}

function Person(name, age) {
    this.name = name
    this.age = age
}

var new1 = NewObj(Person, "pyz", 18)

console.log(new1.name); // "pyz"
console.log(new1.age); // 18

不能使用箭头函数，箭头函数没有this指向。因为构造函数存在多参数，所以需要使用args语法。
```



## 手写 Objet.create

```javascript
function createObject(proto) {
    function F() {}
    F.prototype = proto;
    return new F();
}
```



##  new与creat之间的区别

相同之处：都是生成某一个构造函数的实例对象。

不同之处：create不会执行构造函数。它只会创建一个新对象，并将其原型设置为指定的对象