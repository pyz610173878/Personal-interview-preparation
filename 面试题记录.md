# js的作用域

## 历史

在等早期编程语言中，没有明确的作用域概念。所有声明的变量和函数实际上都是全局的，这意味着它们可以在程序的任何地方被访问和修改。这种隔离的缺失导致了代码管理的困难，随着软件的规模越来越大，软件可维护性成本越来越高。

JavaScript 的作用域分以下三种：

* 全局作用域：脚本模式运行所有代码的默认作用域
* 模块作用域：模块模式中运行代码的作用域
* 函数作用域：由[函数](https://developer.mozilla.org/zh-CN/docs/Glossary/Function)创建的作用域

这种隔离方法，同样可以运用在模块的设计方面。这里说的深一点，其实有很多知识。

数据隐藏和访问控制：

隔离思想鼓励数据隐藏和访问控制。通过只公开必要的接口并将实现细节保密，可以限制外部对内部数据和函数的访问。
作用域在控制可见性方面发挥了作用。在特定作用域内声明的变量和函数对外部作用域是隐藏的，而对内部数据和函数的访问则是透明的。



# 闭包的作用和原理以及使用场景

```
#d 闭包的历史
闭包拥有其悠久的理论基础与背景。最早源于一个名为lambda微积分，该微积分引入了函数作为一等公民的概念，为包括闭包在内的函数式编程概念奠定了基础，他与函数式编程紧密关联。
#d 闭包是什么
在JavaScript中，创建函数的同时就会创建闭包这个环境。闭包的作用就是从内部函数访问外部函数的作用域。
通常情况下，因为局部作用域的关系，函数内部的变量外部无法访问到。而闭包的作用，就具备实现了能在外部访问某个函数内部变量的功能，让这些内部变量的值始终可以保存在内存中。所以说，闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数。

#d 与什么类似 和作用
闭包的作用类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。而闭包允许将函数与其所操作的某些数据（环境）关联起来。所以说闭包可以将变量和函数私有化，从而避免命名冲突和变量污染。

关联环境。内部函数为一个环境，外部函数又为一个环境，我们把这两个环境关联起来。其他函数无法访问，所以实现了变量与函数的私有化。避免变量命名的冲突和变量污染。


#e 常见的使用场景

用于事件处理和回调函数。 
3 用于封装类和模块。
4 用于实现柯里化和函数式编程。 
5 用于解决循环中异步问题。 
展现了如何使用闭包来定义公共函数，并令其可以访问私有函数和变量
这里最好需要举例子。等下用gpt搜索一下。


#d vue中使用闭包的例子

比如，在 Vue 的组件定义中，会用到一个 data 函数来返回一个对象，这个函数就是一个闭包，在组件实例化的过程中，每个实例都会得到一个独立的数据对象。




#d 常见的错误 在循环中使用闭包


#d 使用闭包的注意事项
如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。。


#d 内存泄露
当一个函数返回一个内部函数，而该内部函数持有外部函数的变量时，就会形成闭包。如果该内部函数在外部函数执行结束后仍然存在，那么它会一直持有外部函数的变量，导致这些变量无法被垃圾回收器回收，从而造成内存泄漏。
```







## 闭包的作用

闭包的作用类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。而闭包允许将函数与其所操作的某些数据（环境）关联起来。闭包可以将变量和函数私有化，从而避免命名冲突和变量污染。







闭包的原理是在内存中创建一个包含函数和变量的环境，当函数返回后，该环境仍然存在于内存中，因此可以被其他函数访问和使用。闭包中的变量和函数可以被多次调用和修改，因此可以实现许多高级功能。

## 例子1

## 使用场景

以下是一些常见的使用场景： 

1 保存变量状态和私有化变量和函数。

2 用于事件处理和回调函数。 

3 用于封装类和模块。

4 用于实现柯里化和函数式编程。 

5 用于解决循环中异步问题。 

6 用于实现缓存和记忆化等功能。



## vue中

比如，在 Vue 的组件定义中，会用到一个 data 函数来返回一个对象，这个函数就是一个闭包，在组件实例化的过程中，每个实例都会得到一个独立的数据对象。





```
#d 历史

```

# 闭包的作用和原理以及使用场景 

换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。假设我们现在创建了一个函数并定义了一个变量，我们把它叫做父函数。与此同时在该函数内部又嵌套着创建了一个函数称作子函数，闭包的作用就是子函数能够访问外部函数的作用域。进一步猜想，那么我们能否修改父函数的值呢？经过验证，除了用const定义的变量值无法修改，var与let定义的值都能够在子函数中进行修改。



## 闭包的使用场景：

需要结合自己的业务场景和实际中做项目的场景，进行解释是最好的。

这是别人总结出来的指令性描述，你直接背是没有任何意义的。你也不好理解。

你要自己去招例子。特别是在项目中去找例子。特别是一开始没有使用闭包，然后使用闭包，实现了什么。最好的情况就是，富有激情的讲，当时解bug的情形。那是再号不过的。让技术面试官觉得你对技术拥有热情。



```
举一个实际的例子。我有一个需求，我需要存储用户点击某个按钮的次数，到达某个临界值禁用按钮。普通的函数无法解决这个问题，
因为每次运行函数，变量的值都会重置，无法存储。我们就可以使用闭包解决这个问题。
```



### vue3的声明式变量

vue3中的ref方法就是一个闭包，他所定义的变量不会随着函数的执行而销毁在内存中。而是保留在闭包环境中。

### 





 闭包的应用非常广泛，特别是在异步编程和模块化开发中。以下是一些常见的使用场景： 1 保存变量状态和私有化变量和函数。 2 用于事件处理和回调函数。 3 用于封装类和模块。 4 用于实现柯里化和函数式编程。 5 用于解决循环中异步问题。 6 用于实现缓存和记忆化等功能。

Vue &react 在 Vue 和 React 中，也有使用到闭包的地方。

比如，在 Vue 的组件定义中，会用到一个 data 函数来返回一个对象，这个函数就是一个闭包，在组件实例化的过程中，每个实例都会得到一个独立的数据对象。在 React 中，由于函数组件没有自己的实例，所以在使用 useState 和 useEffect 等 Hook 时，也会用到闭包的概念来保存组件内部的状态。 另外，在 Vue 和 React 中，由于都是响应式框架，会自动处理视图的更新，而这个过程中也会用到闭包。比如，在 Vue 中，会为每个组件创建一个 Watcher 对象来监听数据的变化，这个 Watcher 对象就是一个闭包，它持有了组件实例、渲染函数以及需要监听的数据，从而实现了自动更新视图的功能。在 React 中，也有类似的机制，即 useEffect Hook，它会在组件渲染时执行一个副作用函数，并将这个函数存储在组件实例中，以便在下次渲染时比较前后两个副作用函数是否相同，从而决定是否执行它们。这个过程中也会用到闭包的概念。





# 0.1+0.2为什么不等于0.3

```
#d 核心
其核心涉及到浮点数的二进制表示方式，在许多编程语言中包括 JavaScript其表示方式为EEE 754，这种表示方式是使用固定的二进制位数，这意味着她们只能近似地表示十进制数，而不能精确地表示十进制。所以导致表达式 0.1 + 0.2 并不完全等于 0.3，他的值是一个非常接近0.3的数字。

#d 信息的表示方式
有符号与正负号的整数，浮点数的表示方式。
```

这其中涉及计算机中信息的表示方式。

```
const sum = 0.1 + 0.2; // 0.30000000000000004 
const roundedSum = sum.toFixed(1); 
// "0.3"console.log(roundedSum === "0.3"); // true
```





# es6新特性？ES7箭头函数和普通函数有啥区别？箭头函数能当构造函数吗？





es6中，包括以下几个部分的特性。

1. 新增了 const 和 let 关键字。const定义地变量为常量，即定义后值无法进行更改的变量。就像你的身份证号码，你出现就决定了。这个关键字来源与c语言。let生成的变量具有块级作用域的功能。值的访问与修改只在某一个范围之内。超出作用域无法生效。
2. 箭头函数，函数生成的新方式。具有简化的语法和自动判定this上下文的特点。
3. 模板字符串，使用反引号 和相关操作符，其作用方便拼接字符串和变量。
4. 解构赋值。可以将数组和对象的值解构赋值给变量。
5. 类和继承。使得JavaScript支持面向对象编程范式。
6. 新增处理异步编程新特性  promise 和  await。社交媒体平台需要异步获取用户数据、帖子和评论



```
当然，以下是ES7（ECMAScript 2016）和ES8（ECMAScript 2017）中引入的一些新特性在真实业务场景中的文字描述：

1. Array.prototype.includes (ES7)：

业务场景：在电子商务应用程序中，网站的购物车需要在用户添加产品时检查特定项目是否已经在购物车中。使用 Array.prototype.includes，应用程序可以快速确定项目是否已经在购物车中，确保顺畅的购物体验。
2. Exponentiation Operator (ES7)：

业务场景：金融应用程序需要计算投资的复利。指数运算符允许应用程序轻松地计算投资随时间的未来价值，简化了复杂的金融计算。
3. Async/Await (ES8)：

业务场景：社交媒体平台需要异步获取用户数据、帖子和评论。使用 async/await 简化了异步API请求的代码，确保平台可以高效显示用户内容，并保持响应迅速的用户体验。
4. Object.values 和 Object.entries (ES8)：

业务场景：内容管理系统用于管理文章，并需要提取文章属性的值或生成带有标题和内容的文章列表。Object.values 和 Object.entries 简化了数据提取和报告，提高了内容管理的效率。
5. String Padding (ES8)：

业务场景：会计软件应用程序生成带有数字对齐列的财务报告。字符串填充功能确保数字以一致的方式格式化，提供专业和有组织的财务文件外观。
6. Atomics (ES8)：

业务场景：科学模拟应用程序执行需要协调多个线程以优化性能的复杂模拟。Atomics API有助于确保模拟中的数据一致性和完整性，提供更准确的结果和更快的计算。
这些文字描述突出了ES7和ES8功能如何应用于解决各种业务领域的实际问题，如电子商务、金融、社交媒体、内容管理、会计和科学计算。这些功能在简化和提高真实世界应用程序的效率方面发挥了重要作用。
```



## 我觉得会有promise 手写题













# 如何判断一个对象是不是空对象

你可以使用多种方法来检查 JavaScript 中的对象是否为空。以下是一些常用方法：

最好用的方法就是使用keys方法，该方法检测对象是否有属性。



**1. 使用 `Object.keys()`:** 该方法检查对象是否没有自有属性。

```
javascriptCopy codefunction isEmpty(obj) {
    return Object.keys(obj).length === 0;
}
```

示例：

```
codeconst emptyObject = {};
const nonEmptyObject = { key: 'value' };

console.log(isEmpty(emptyObject)); // true
console.log(isEmpty(nonEmptyObject)); // false
```

**2. 使用 `for...in` 循环:** 通过对象的属性进行迭代，检查是否存在任何属性。

```
javascriptCopy codefunction isEmpty(obj) {
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            return false;
        }
    }
    return true;
}
```

**3. 使用 `Object.getOwnPropertyNames()`:** 与 `Object.keys()` 类似，该方法检查对象是否没有自有属性。

```
javascriptCopy codefunction isEmpty(obj) {
    return Object.getOwnPropertyNames(obj).length === 0;
}
```

**4. 使用 `JSON.stringify()`:** 将对象转换为 JSON 字符串，然后检查是否是空对象。

```
javascriptCopy codefunction isEmpty(obj) {
    return JSON.stringify(obj) === '{}';
}
```

请注意，最后一种方法有一些限制，例如，不适用于包含函数或未定义值的属性的对象。

选择最适合您用例的方法。使用 `Object.keys()` 方法的第一种方法是一种常见且可靠的方式来检查对象是否为空。



# 什么是BOM **和** DOM？分别列举⼀些它们的函数

```
#d 是什么
dom，全名叫文档对象模型。首先DOM 不是一种编程语言，他也不是 JavaScript 语言的一部分。文档对象模型（DOM）是一个网络文档的编程接口。DOM 被设计成与特定编程语言相独立，使文档的结构化表述可以通过单一，一致的 API 获得。
它代表页面，以便程序可以改变文档的结构、风格和内容。DOM 将文档表示为节点和对象；如此编程语言就可以与页面交互。
2. DOM 把⽂档看作⼀个对象来看待。
3. DOM 的顶级对象是 document。
4. DOM 主要学习的是操作⻚⾯元素。

常⽤接⼝函数：
getElementById 根据Id名获取⽂档的元素对象
getElementsByTagName 根据标签名获取元素对象集合，以伪数组的形式存储
getElementsByClassName 根据类名获取元素集合
querySelector ('符号+选择器')返回指定选择器的第⼀个对象
querySelectorAll ('符号+选择器')返回指定选择器的所有元素对象集合
appendChild 将⼀个节点添加到指定⽗节点的⼦节点列表的末尾。
```





网页是一个既可以在浏览器窗口中显示，也可以作为 HTML 源代码的文档。在这两种情况下，它都是同一个文档，但文档对象模型（DOM）的表示方式使它可以被操作。作为一个面向对象的网页表示，它可以用脚本语言（如 JavaScript）进行修改。











# js事件流

讲概念 JavaScript 事件流（Event flow）指的是浏览器处理事件的方式。 详细说 在 JavaScript 中，事件流分为三个阶段：捕获阶段、目标阶段和冒泡阶段。这三个阶段是从外到内，从父节点到子节点，再从子节点到父节点的顺序依次发生。

 事件流的过程如下：

 1 捕获阶段：事件从最外层的节点（文档对象）开始，逐级向下传播，直到达到事件的目标节点。 

2 目标阶段：事件到达目标节点，触发目标节点上的事件处理函数。 

3 冒泡阶段：事件从目标节点开始，逐级向上传播，直到达到最外层的节点（文档对象）。

在事件流中，事件的传播过程可以被停止或取消。在事件处理函数中，可以使用 event.stopPropagation() 方法阻止事件的进一步传播，或者使用 event.preventDefault() 方法取消事件的默认行为。



## 总结一下

事件流是指描述事件在页面元素中传播的顺序，包括事件捕获阶段、目标阶段和事件冒泡阶段。在事件捕获阶段中，事件从最外层的元素开始向下传递，直到目标元素；在目标阶段中，事件在目标元素上触发；在事件冒泡阶段中，事件从目标元素开始向上冒泡，直到最外层的元素。









# let const var 之间的区别

（1）块级作用域：块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：  ● 内层变量可能覆盖外层变量 ● 用来计数的循环变量泄露为全局变量  

（2）变量提升：var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。  

（3）给全局添加属性：浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。  

（4）重复声明：var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。  

（5）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。  

（6）初始值设置：在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。  

（7）指针指向：let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。



# 1. this 指向

<img src="%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95.assets/image-20231108172420616-16994354617181.png" alt="image-20231108172420616" style="zoom:50%;" />









# Promise

ES6之后引入，用于实现异步编程的特殊对象；衍生开来，ES7 后被用于实现 async-await 语法。

在 promise 之前，异步操作通常通过注册 callback 回调方式处理异步结果，很容易带来回调地狱问题，最终造成代码结构非常不清晰，不直观，维护成本较高(回调地狱)。他类似于早起某种编程语言存在的



## 1. 同步任务编程

## 2. 事件处理程序

```
const fetchPromise = fetch(
  "https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json",
);

fetchPromise.then((response) => {
  const jsonPromise = response.json();
  jsonPromise.then((json) => {
    console.log(json[0].name);
    console.log(1);
  });
});

```





## 3. 错误捕获

.catch方法优雅地解决了回调函数中调来捕获问题。



这给我们带来了最后一个问题：我们如何处理错误？`fetch()` API 可能因为很多原因抛出错误（例如，没有网络连接或 URL 本身存在问题），我们也会在服务器返回错误消息时抛出一个错误。

在上一篇文章中，我们看到在嵌套回调中进行错误处理非常困难，我们需要在每一个嵌套层中单独捕获错误。

### cath的作用

`Promise` 对象提供了一个 [`catch()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch) 方法来支持错误处理。这很像 `then()`：你调用它并传入一个处理函数。然后，当异步操作*成功*时，传递给 `then()` 的处理函数被调用，而当异步操作*失败*时，传递给 `catch()` 的处理函数被调用。

### 第二个作用

如果将 `catch()` 添加到 Promise 链的末尾，它就可以在任何异步函数失败时被调用。于是，我们就可以将一个操作实现为几个连续的异步函数调用，并在一个地方处理所有错误。

试试这个版本的 `fetch()` 代码。我们使用 `catch()` 添加了一个错误处理函数，并修改了 URL（这样请求就会失败）。

```
他类似于同步编程中的try，catch。
```







# js如何判断数据类型

最原始的办法使用，typeof，该方法接受一个值，（比如 字符串，数组，函数）我们可以把他看成某个原型对象的实例对象，而typeof返回的就是对应的原型对象的构造函数。 

第二个方法，instanceof，他接受两个参数，原型对象和实例对象。他会判断构造函数的prototype属性是否存在某个实例对象的原型链上，我们前面也说过了，具体的数字类型值就是某些原型对象的实例对象。

Object.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型：











```
我要努力冲，寒假的实习。我跟你说。到时候我就有两段实习经历。明年的春招，，甚至秋招，我就更有竞争力了。
```

