# 异步编程

JavaScript 是单线程事件循环模型。

异步行为是为了优化因计算量大而时间长的操作。如果在等待其他操作完成的同时，即使运行其他指令，系统也能保持稳定，那么这样做就是务实的。

重要的是，异步操作并不一定计算量大或要等很长时间。只要你不想为等待某个异步操作而阻塞线程执行，那么任何时候都可以使用。



## 1.1 同步与异步

同步行为对应内存中顺序执行的处理器指令。每条指令都会严格按照它们出现的顺序来执行。

1. 你和朋友一起去看电影，你需要等待朋友的到来才能开始看电影。
2. 你和朋友一起去玩游戏，你需要等待朋友的到来才能开始玩游戏。
3. 比如泡面，你必须把水烧开才能泡面，任务的执行顺序无法更改。
4. 比如我们初高的学科学习，课本的学习顺序，只能从第一章到最后一章。学习顺序严格按照章节来执行。



异步编程技术使你的程序可以在执行一个可能**长期运行**的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。

1. 火车站的排队：当你在火车站排队时，你不能阻止其他人排队，但你可以在等待的过程中做其他的事情。
2. 餐厅的排队：当你在餐厅排队时，你不能阻止其他人排队，但你可以选择在等待的过程中看书、玩手机或者做其他的事情。
3. 泡茶。我可以边烧水，边洗茶具。烧水这个运行的任务的同时我可以洗茶具，不必等烧水完成之后才能洗茶具，与此同时烧水任务完成过后显示结果。
4. 比如访问一些高延迟的资源，比如向远程服务器发送请求并等待响应，那么就会出现长时间的等待。（这是一个长期运行的任务，需要长时间等待）我们可以不必他执行完毕才执行后面的代码。先让他一个人执行，继续执行后面的任务。

事件处理程序也是一种异步行为。事件的处理是用户决定的。比如我定义了一个事件处理程序，他的作用是为用户点击button按钮弹出提示框。那么这个程序就是一个异步程序，因为他是一个长期运行的任务（如果用户一直不点击，程序不会触发，且我们能处理以后的程序。）

我们刚才看到的对异步函数的描述可能会让你想起事件处理程序，这么想是对的。事件处理程序实际上就是异步编程的一种形式：你提供的函数（事件处理程序）将在事件发生时被调用（而不是立即被调用）。







## 早期的异步编程模式

只支持定义回调函数来表明异步操作完成。串联多个异步操作是一个常见的问题，通常需要深度嵌套的回调函数（俗称“回

调地狱”）来解决。嵌套回调就是异步返值又依赖另一个异步返回值，随着嵌套的层级越高，情况会进一步复杂，我们把这种叫做回调地狱。



## 介绍promise 







## promise 的链式调用（三个最重要的方法）

三个方法。`then` `catch` `finally`  then解决了回调地狱问题。

`.then()` 方法最多接受两个参数；第一个参数是 Promise 兑现时的回调函数，第二个参数是 Promise 拒绝时的回调函数。每个 `.then()` 返回一个新生成的 Promise 对象，这个对象可被用于链式调用



catch类似于，程序中的异常处理，try catch。我们把catch用来判断异步操作是否执行成功，如果没有成功返回异常错误情况，如果成功了则跳过。返回promise对象错误的提示。



### then 具体例子 状态码401

为了确保用户账号的安全性，服务端会会为每个账号设置一个唯一的标识符。每隔一段时间，标识符就会进行更改。如果不匹配服务器返回 401 状态码，这表示用户的会话已经过期或者无效，需要重新登录。我们可以使用then方法处理匹配不成功的情况（具体代码就是注销账号并返回到登录界面。），catch处理非重新登录情况，使用Promise.reject返回弹框信息。





### 文件下载功能

函数的参加与流程。

但是后端返回数据，或者执行复杂计算是需要长时间的。这里就需要使用then来执行异步操作，

然后，它使用 `service.post` 方法发送一个 POST 请求到指定的 `url`，并将 `params` 作为请求体。这个请求的 `Content-Type` 被设置为 `application/x-www-form-urlencoded`，并且 `responseType` 被设置为 `blob`，这意味着服务器返回的数据将被解析为 Blob 对象。

当请求成功时，它会调用 `blobValidate` 函数，但是函数的处理不是一下子就能执行完毕的。它可能需要从服务器获取数据，或者执行一些复杂的计算。为了避免堵塞，我们就可以使用await 关键字。等待`blobValidate(data)`函数的结果。我们需要在处理的同时，与此同时执行能够执行其他代码所以这里可以使用`async`关键字。

如果验证通过，它会创建一个新的 Blob 对象，并使用 `saveAs` 函数将 Blob 对象保存为文件。如果验证失败，它会解析返回的数据，并显示错误消息。





## 回调函数 promise  async await 之间的区别



### 什么是回调函数  回调函数的缺点  如何解决回调地狱问题

回调函数（Callback）是一种在 JavaScript 中常用的编程模式。一个函数作为参数传递给另一个函数，并在某个特定事件或条件满足时被调用。这种模式允许我们将一些需要在特定时刻执行的代码封装起来，以便在需要的时候调用。

以下是一些回调函数的基本使用示例：

1. 定义一个回调函数：

```
function greet(name, callback) {
  console.log('Hello, ' + name);
  callback();
}
```

在这个例子中，我们定义了一个 `greet` 函数，它接受两个参数：一个名字和一个回调函数。当我们调用 `greet` 函数时，它会打印出一条问候语，然后调用回调函数。

1. 使用回调函数：

```
greet('Alice', function() {
  console.log('This is a callback function.');
});
```

在这个例子中，我们调用了 `greet` 函数，并传入了两个参数：一个名字（'Alice'）和一个回调函数。当 `greet` 函数被调用时，它会打印出一条问候语，然后调用回调函数。

1. 使用箭头函数简化回调函数：

```
greet('Alice', () => console.log('This is a callback function.'));
```

在这个例子中，我们使用了箭头函数来简化回调函数的定义。箭头函数是一种更简洁的函数定义方式，它可以让我们在需要的时候直接调用函数，而不需要定义一个新的函数。



在这个例子中，我们有三个异步调用，每个调用都依赖于前一个调用的结果。这就导致了回调地狱，使得代码难以理解和维护。

## 对promise 的理解

promise是一个构造函数。我们可以通过new关键字生成一个promise实例对象。该构造函数接受一个`executor` 函数作为参数，这个函数有两个参数：`resolve` 和 `reject`。







## promise 的基本用法





## promise 解决了什么问题



## all方法 和 race方法 的区别和使用场景

他们的共性：都是用于处理多个Promise对象的。

`all`方法接收一个Promise对象的数组作为参数，并返回一个新的Promise对象。这个新的Promise对象在所有的Promise对象都成功时才会成功，如果有一个Promise对象失败，那么新的Promise对象就会立即失败。

```
const promise1 = Promise.resolve(3);
const promise2 = 42;
const promise3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, 'foo');
});

Promise.all([promise1, promise2, promise3]).then((values) => {
  console.log(values);
});
// Expected output: Array [3, 42, "foo"]

all方法常用于需要等待所有Promise对象都完成后再进行下一步操作的场景。例如，你可能需要同时从多个API获取数据，然后在所有数据都获取完成后再进行下一步操作。
```

`race`方法也接收一个Promise对象的数组作为参数，并返回一个新的Promise对象。这个新的Promise对象在第一个完成的Promise对象成功或失败时就会完成。





## 对async 和await 的理解





### 是什么

async 函数是使用`async`关键字声明的函数。async 函数是`AsyncFunction`构造函数的实例，并且其中允许使用 `await` 关键字。

语法关键字。

### 作用与好处

`async` 和 `await` 关键字让我们可以用一种更简洁的方式写出基于`Promise` 的异步行为，也就是说用同步方式写的代码能够异步执行，而无需刻意地链式调用 `promise`。

```typescript
let p = new Promise((resolve, reject) => setTimeout(resolve, 1000, 3));
```









## await 到底在等啥?



# js事件轮询机制

讲概念 JavaScript 事件轮询（Event Loop）是一种异步编程模型，用于处理 JavaScript 中的事件和回调函数。JavaScript 事件轮询机制可以使得单线程的 JavaScript 能够处理多个任务，从而实现异步编程。  

详细答 在浏览器中，JavaScript 事件轮询机制由浏览器的事件循环（Event Loop）负责执行。事件循环是一种机制，它会不断地轮询任务队列（Task Queue），并将队列中的任务依次执行。 

JavaScript 中的任务可以分为两类：宏任务（Macro Task）和 微任务（Micro Task）。 

宏任务通常包括一些需要花费较长时间的操作，例如定时器、事件回调等等。当一个宏任务执行完毕后，JavaScript 引擎会检查是否存在未执行的微任务，如果存在，则立即执行这些微任务。在所有微任务执行完毕后，JavaScript 引擎会再次开始执行宏任务。 

微任务通常包括一些需要尽快执行的操作，例如 Promise 的回调函数、MutationObserver 的回调函数等等。微任务可以使用 Promise 对象的 then() 方法或者 MutationObserver 的 observe() 方法注册。 

在 JavaScript 中，事件轮询机制的执行顺序如下： 

1 执行当前宏任务中的同步代码，直到遇到第一个宏任务或微任务。

 2 如果遇到微任务，则将它添加到微任务队列中，继续执行下一个同步代码。

 3 如果遇到宏任务，则将它添加到宏任务队列中，继续执行下一个同步代码。

 4 当前微任务或者宏任务执行完毕后，JavaScript 引擎会检查微任务或宏任务队列是否为空。如果不为空，则执行队列中的第一个任务，重复执行该步骤直到任务队列为空。 

5 当前事件轮询结束，等待下一次事件的触发。 

需要注意的是，JavaScript 中的事件轮询机制是单线程的，也就是说，所有任务都是在同一个线程中执行的，不能同时执行两个任务。如果当前宏任务执行的时间太长，会阻塞其它宏任务的执行，从而导致应用程序的性能问题。因此，在编写 JavaScript 代码时，应该尽可能避免长时间的同步操作，而是使用异步操作，以保证应用程序的性能和响应速度。

